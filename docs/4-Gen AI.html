<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>AI FOR ALL - Gen AI Applied Specialist Interview Quiz</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .quiz-container {
            max-width: 1100px;
            margin: 0 auto;
            background: white;
            border-radius: 20px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
            overflow: hidden;
        }

        .quiz-header {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 30px;
            text-align: center;
        }

        .quiz-header h1 {
            font-size: 2.5em;
            margin-bottom: 10px;
            font-weight: 300;
        }

        .quiz-progress {
            background: rgba(255,255,255,0.2);
            padding: 15px;
            border-radius: 10px;
            margin: 20px 0;
        }

        .progress-bar {
            width: 100%;
            height: 10px;
            background: rgba(255,255,255,0.3);
            border-radius: 5px;
            overflow: hidden;
            margin: 10px 0;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #fff, #f8f9fa);
            width: 0%;
            transition: width 0.3s ease;
        }

        .question-counter {
            font-size: 1.1em;
        }

        .score-display {
            background: rgba(255,255,255,0.2);
            padding: 10px 20px;
            border-radius: 25px;
            display: inline-block;
            margin-top: 10px;
        }

        .quiz-main {
            padding: 30px;
        }

        .screen {
            display: block;
        }

        .hidden {
            display: none;
        }

        #start-screen h2 {
            color: #2c3e50;
            margin-bottom: 20px;
        }

        #start-screen p {
            color: #7f8c8d;
            margin-bottom: 15px;
        }

        #start-screen ul {
            margin: 20px 0;
            padding-left: 20px;
        }

        #start-screen li {
            margin: 8px 0;
            color: #34495e;
        }

        .btn-primary {
            background: linear-gradient(135deg, #007bff, #6610f2);
            color: white;
            border: none;
            padding: 15px 40px;
            font-size: 1.1em;
            border-radius: 25px;
            cursor: pointer;
            transition: transform 0.2s ease;
        }

        .btn-primary:hover {
            transform: translateY(-2px);
        }

        .btn-secondary {
            background: #6c757d;
            color: white;
            border: none;
            padding: 12px 25px;
            border-radius: 20px;
            cursor: pointer;
        }

        #question-screen {
            background: #f8f9fa;
            border-radius: 15px;
            padding: 30px;
        }

        .question-section {
            background: linear-gradient(135deg, #007bff, #6610f2);
            color: white;
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 25px;
            text-align: center;
        }

        .question-content {
            background: white;
            padding: 25px;
            border-radius: 10px;
            margin-bottom: 25px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        #question-text {
            font-size: 1.3em;
            color: #2c3e50;
            margin-bottom: 25px;
            line-height: 1.4;
        }

        .options {
            display: grid;
            gap: 15px;
            margin: 20px 0;
        }

        .option {
            background: white;
            border: 2px solid #e9ecef;
            border-radius: 10px;
            padding: 15px;
            cursor: pointer;
            transition: all 0.3s ease;
            position: relative;
        }

        .option:hover {
            border-color: #007bff;
            transform: translateX(5px);
        }

        .option.selected {
            border-color: #007bff;
            background: #e7f3ff;
        }

        .option.correct {
            border-color: #28a745;
            background: #d4edda;
        }

        .option.incorrect {
            border-color: #dc3545;
            background: #f8d7da;
        }

        input[type="radio"] {
            margin-right: 10px;
        }

        label {
            font-size: 1.1em;
            color: #495057;
            cursor: pointer;
        }

        .question-navigation {
            display: flex;
            justify-content: space-between;
            margin: 25px 0;
        }

        .feedback {
            background: #e7f3ff;
            border: 1px solid #b8daff;
            color: #004085;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
            text-align: center;
        }

        .feedback.correct {
            background: #d4edda;
            border-color: #c3e6cb;
            color: #155724;
        }

        .feedback.incorrect {
            background: #f8d7da;
            border-color: #f5c6cb;
            color: #721c24;
        }

        #result-screen {
            text-align: center;
            padding: 40px;
        }

        .result-stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 25px;
            margin: 30px 0;
        }

        .final-score {
            background: linear-gradient(135deg, #007bff, #6610f2);
            color: white;
            padding: 25px;
            border-radius: 15px;
        }

        .score-breakdown {
            display: grid;
            gap: 15px;
        }

        .score-item {
            background: white;
            padding: 15px;
            border-radius: 10px;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }

        .score-label {
            color: #6c757d;
        }

        .score-value {
            font-weight: bold;
            color: #28a745;
        }

        .score-value.correct {
            color: #28a745;
        }

        .score-value.incorrect {
            color: #dc3545;
        }

        .score-value.skipped {
            color: #ffc107;
        }

        .performance-badge {
            background: linear-gradient(135deg, #28a745, #20c997);
            color: white;
            padding: 25px;
            border-radius: 15px;
            margin: 25px 0;
        }

        .result-actions {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin-top: 30px;
        }

        .quiz-footer {
            text-align: center;
            padding: 20px;
            background: #f8f9fa;
            color: #6c757d;
        }

        .quiz-footer a {
            color: #007bff;
            text-decoration: none;
        }

        .quiz-footer a:hover {
            text-decoration: underline;
        }

        .code-snippet {
            background: #f8f9fa;
            border: 1px solid #e9ecef;
            border-radius: 5px;
            padding: 15px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 0.9em;
        }

        .interview-notice {
            background: #fff3cd;
            border: 1px solid #ffeaa7;
            color: #856404;
            padding: 15px;
            border-radius: 8px;
            margin: 20px 0;
        }

        @media (max-width: 768px) {
            .quiz-container {
                margin: 10px;
                border-radius: 10px;
            }

            .quiz-header h1 {
                font-size: 2em;
            }

            .question-navigation {
                flex-direction: column;
                gap: 15px;
            }

            .result-actions {
                flex-direction: column;
                align-items: center;
            }
        }
    </style>
</head>
<body>
    <div class="quiz-container">
        <header class="quiz-header">
            <h1>üéØ AI FOR ALL - Gen AI Applied Specialist Interview Quiz</h1>
            <div class="quiz-progress">
                <div class="progress-bar">
                    <div class="progress-fill"></div>
                </div>
                <div class="question-counter">Question <span id="current-question">1</span> of <span id="total-questions">50</span></div>
            </div>
            <div class="score-display">
                <span class="current-score">Score: <span id="score">0</span></span>
            </div>
        </header>

        <main class="quiz-main">
            <div class="interview-notice">
                <strong>üé§ Interview Mode:</strong> These questions simulate real Generative AI specialist interviews, testing practical knowledge and problem-solving abilities.
            </div>

            <div id="start-screen" class="screen">
                <h2>Welcome to Gen AI Specialist Interview Quiz!</h2>
                <p>Prepare for Generative AI specialist interviews with 50 challenging questions covering:</p>
                <ul>
                    <li>üîç RAG Systems Architecture & Implementation</li>
                    <li>‚öôÔ∏è Advanced Fine-tuning & LoRA Techniques</li>
                    <li>üëÅÔ∏è Vision Models & Computer Vision</li>
                    <li>üîß OpenAI API & Production Deployment</li>
                    <li>ü§ó Hugging Face Model Management</li>
                    <li>üîó LangChain & Agent Development</li>
                    <li>üêç Production Python Implementation</li>
                    <li>üöÄ Real-world Problem Solving</li>
                </ul>
                <button id="start-btn" class="btn-primary">Start Interview Quiz</button>
            </div>

            <div id="question-screen" class="screen hidden">
                <div class="question-section">
                    <h3 id="question-section">üîç RAG Architecture</h3>
                </div>
                <div class="question-content">
                    <h2 id="question-text">You're building a RAG system for a legal document Q&A. The documents are 100-200 pages each. How do you optimize chunking strategy?</h2>
                    <div class="options">
                        <div class="option" data-letter="a">
                            <input type="radio" id="option-a" name="answer" value="a">
                            <label for="option-a" id="option-a-text">A) Use fixed 512-token chunks with 50-token overlap</label>
                        </div>
                        <div class="option" data-letter="b">
                            <input type="radio" id="option-b" name="answer" value="b">
                            <label for="option-b" id="option-b-text">B) Use semantic chunking based on document structure (sections, paragraphs, sentences)</label>
                        </div>
                        <div class="option" data-letter="c">
                            <input type="radio" id="option-c" name="answer" value="c">
                            <label for="option-c" id="option-c-text">C) Chunk by page numbers only</label>
                        </div>
                        <div class="option" data-letter="d">
                            <input type="radio" id="option-d" name="answer" value="d">
                            <label for="option-d" id="option-d-text">D) Use single chunk per document</label>
                        </div>
                    </div>
                </div>
                <div class="question-navigation">
                    <button id="prev-btn" class="btn-secondary">Previous</button>
                    <button id="next-btn" class="btn-primary">Next</button>
                </div>
                <div class="feedback hidden" id="feedback"></div>
            </div>

            <div id="result-screen" class="screen hidden">
                <h2>Interview Complete! üéâ</h2>
                <div class="result-stats">
                    <div class="final-score">
                        <h3>Final Score</h3>
                        <p id="final-score">0/50</p>
                        <p id="percentage">0%</p>
                    </div>
                    <div class="score-breakdown">
                        <div class="score-item">
                            <span class="score-label">Correct:</span>
                            <span id="correct-count" class="score-value correct">0</span>
                        </div>
                        <div class="score-item">
                            <span class="score-label">Incorrect:</span>
                            <span id="incorrect-count" class="score-value incorrect">0</span>
                        </div>
                        <div class="score-item">
                            <span class="score-label">Skipped:</span>
                            <span id="skipped-count" class="score-value skipped">0</span>
                        </div>
                    </div>
                </div>
                <div class="performance-badge" id="performance-badge">
                    <h4 id="badge-title">Interview Result</h4>
                    <p id="badge-description">Complete the quiz to see your interview performance!</p>
                </div>
                <div class="result-actions">
                    <button id="review-btn" class="btn-secondary">Review Answers</button>
                    <button id="restart-btn" class="btn-primary">Practice Again</button>
                </div>
            </div>
        </main>

        <footer class="quiz-footer">
            <p>Created by <a href="https://www.linkedin.com/in/pusulurisrinivasa/" target="_blank">https://www.linkedin.com/in/pusulurisrinivasa/</a></p>
        </footer>
    </div>

    <script>
        // Gen AI Interview Quiz Questions Database
        class GenAIInterviewQuiz {
            constructor() {
                this.questions = this.parseQuestions();
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.answers = new Array(this.questions.length).fill(null);
                this.scoredQuestions = new Set();
                this.startTime = null;
                this.endTime = null;

                this.initializeElements();
                this.bindEvents();
                this.showStartScreen();
            }

            parseQuestions() {
                return [
                    // RAG Interview Questions (1-10)
                    {
                        section: "üîç RAG Architecture",
                        question: "You're building a RAG system for a legal document Q&A. The documents are 100-200 pages each. How do you optimize chunking strategy?",
                        options: {
                            a: "Use fixed 512-token chunks with 50-token overlap",
                            b: "Use semantic chunking based on document structure (sections, paragraphs, sentences)",
                            c: "Chunk by page numbers only",
                            d: "Use single chunk per document"
                        },
                        correct: "b"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "Your RAG system is experiencing slow response times. What are the most likely bottlenecks and how would you optimize them?",
                        options: {
                            a: "Vector similarity search - implement HNSW indexing",
                            b: "Document preprocessing - use async processing",
                            c: "LLM generation - use smaller models",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "How would you implement hybrid search in a RAG system for better retrieval accuracy?",
                        options: {
                            a: "Combine dense embeddings with sparse BM25 scoring",
                            b: "Use multiple embedding models",
                            c: "Implement cross-encoders for re-ranking",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "What's the best approach to handle context window limitations in RAG for long documents?",
                        options: {
                            a: "Compress chunks using summarization",
                            b: "Implement hierarchical retrieval with document-level then chunk-level search",
                            c: "Use longer context models",
                            d: "Truncate documents"
                        },
                        correct: "b"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "How do you evaluate RAG system performance beyond just accuracy?",
                        options: {
                            a: "Faithfulness, context relevance, answer relevance",
                            b: "Response time and throughput",
                            c: "Cost per query and scalability",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "You're implementing RAG for a multi-tenant SaaS application. How do you handle data isolation?",
                        options: {
                            a: "Separate vector databases per tenant",
                            b: "Use tenant-specific namespaces in vector DB",
                            c: "Implement access control in retrieval logic",
                            d: "Both A and C"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "How would you implement real-time document updates in a RAG system?",
                        options: {
                            a: "Full re-indexing on every update",
                            b: "Incremental updates with version tracking",
                            c: "Background sync processes",
                            d: "Both B and C"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "What's the most effective way to reduce hallucinations in RAG systems?",
                        options: {
                            a: "Use higher temperature settings",
                            b: "Implement better prompt engineering with source citations",
                            c: "Use smaller embedding models",
                            d: "Reduce chunk sizes"
                        },
                        correct: "b"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "How do you optimize embedding costs in a high-volume RAG system?",
                        options: {
                            a: "Use caching for similar queries",
                            b: "Implement query deduplication",
                            c: "Use smaller embedding models",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîç RAG Architecture",
                        question: "What's the best strategy for handling multi-language documents in RAG?",
                        options: {
                            a: "Translate all to English first",
                            b: "Use language-specific embedding models",
                            c: "Implement cross-lingual retrieval",
                            d: "Separate indices per language"
                        },
                        correct: "b"
                    },

                    // Fine-tuning & LoRA Interview (11-20)
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "You're fine-tuning a 7B parameter model for a specific domain. The training data is limited (5k samples). What's your strategy?",
                        options: {
                            a: "Use full fine-tuning with low learning rate",
                            b: "Implement LoRA with rank 16-32",
                            c: "Use QLoRA for memory efficiency",
                            d: "Both B and C"
                        },
                        correct: "d"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "How do you determine the optimal LoRA rank for your specific task?",
                        options: {
                            a: "Use the highest rank that fits in memory",
                            b: "Start with rank 16 and tune based on validation performance",
                            c: "Use rank equal to model dimensions",
                            d: "Rank doesn't matter for performance"
                        },
                        correct: "b"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "What's the most effective way to handle catastrophic forgetting in fine-tuning?",
                        options: {
                            a: "Use very low learning rates",
                            b: "Implement replay buffers with original data",
                            c: "Use regularization techniques",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "How do you optimize training time for LoRA fine-tuning?",
                        options: {
                            a: "Use gradient accumulation",
                            b: "Implement mixed precision training",
                            c: "Use DeepSpeed or Accelerate",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "What's the best approach for hyperparameter tuning in LoRA?",
                        options: {
                            a: "Grid search over all parameters",
                            b: "Bayesian optimization",
                            c: "Tune learning rate and rank first",
                            d: "Use default values"
                        },
                        correct: "c"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "How do you handle class imbalance in fine-tuning datasets?",
                        options: {
                            a: "Use weighted loss functions",
                            b: "Implement data augmentation",
                            c: "Use focal loss",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "What's the optimal batch size strategy for LoRA fine-tuning?",
                        options: {
                            a: "Use maximum possible batch size",
                            b: "Use gradient accumulation for effective larger batches",
                            c: "Batch size doesn't affect performance",
                            d: "Use batch size of 1"
                        },
                        correct: "b"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "How do you implement early stopping in LoRA fine-tuning?",
                        options: {
                            a: "Monitor validation loss",
                            b: "Use patience parameter",
                            c: "Save best model checkpoints",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "What's the most effective way to merge LoRA adapters?",
                        options: {
                            a: "Simple weight addition",
                            b: "Use merge_and_unload()",
                            c: "Convert to full fine-tuned model",
                            d: "Keep adapters separate"
                        },
                        correct: "b"
                    },
                    {
                        section: "‚öôÔ∏è Fine-tuning & LoRA",
                        question: "How do you handle distributed training with LoRA?",
                        options: {
                            a: "Use DeepSpeed ZeRO",
                            b: "Implement FSDP",
                            c: "Use Accelerate",
                            d: "All of the above"
                        },
                        correct: "d"
                    },

                    // Vision Models Interview (21-30)
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "You're building a computer vision system for autonomous vehicles. Which model architecture would you choose and why?",
                        options: {
                            a: "CNN for real-time performance",
                            b: "ViT for better accuracy",
                            c: "Hybrid CNN+Transformer for best of both",
                            d: "YOLO for object detection"
                        },
                        correct: "c"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "How would you optimize a vision model for mobile deployment?",
                        options: {
                            a: "Model quantization and pruning",
                            b: "Knowledge distillation",
                            c: "TensorRT optimization",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "What's the most effective way to handle domain shift in vision models?",
                        options: {
                            a: "Collect more training data",
                            b: "Use domain adaptation techniques",
                            c: "Implement style transfer",
                            d: "Both A and B"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "How do you implement multi-task learning in vision models?",
                        options: {
                            a: "Shared backbone with task-specific heads",
                            b: "Separate models for each task",
                            c: "Ensemble of specialized models",
                            d: "Single model for all tasks"
                        },
                        correct: "a"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "What's the best approach for real-time video analysis?",
                        options: {
                            a: "Process every frame",
                            b: "Use frame sampling and interpolation",
                            c: "Implement optical flow",
                            d: "Use temporal models"
                        },
                        correct: "b"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "How do you handle occlusion in object detection?",
                        options: {
                            a: "Use multi-view cameras",
                            b: "Implement occlusion-aware models",
                            c: "Use depth information",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "What's the most effective data augmentation strategy for vision models?",
                        options: {
                            a: "Random crops and flips",
                            b: "Mixup and CutMix",
                            c: "Domain-specific augmentations",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "How do you implement model interpretability for vision models?",
                        options: {
                            a: "Grad-CAM for heatmaps",
                            b: "Layer-wise relevance propagation",
                            c: "Integrated gradients",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "What's the best way to handle class imbalance in vision datasets?",
                        options: {
                            a: "Weighted loss functions",
                            b: "Data augmentation for minority classes",
                            c: "Focal loss",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üëÅÔ∏è Vision Models",
                        question: "How do you optimize vision models for edge deployment?",
                        options: {
                            a: "Model compression and quantization",
                            b: "Hardware-specific optimization",
                            c: "Efficient architecture design",
                            d: "All of the above"
                        },
                        correct: "d"
                    },

                    // OpenAI API Interview (31-40)
                    {
                        section: "üîß OpenAI API",
                        question: "You're building a production application using OpenAI API with 1000+ daily users. How do you optimize for cost and performance?",
                        options: {
                            a: "Implement caching for similar queries",
                            b: "Use fine-tuned models for specific tasks",
                            c: "Implement request batching",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "How do you implement function calling in a complex agent system?",
                        options: {
                            a: "Define comprehensive function schemas",
                            b: "Implement error handling and retries",
                            c: "Use streaming for real-time responses",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "What's the best strategy for handling API rate limits in production?",
                        options: {
                            a: "Implement exponential backoff",
                            b: "Use request queuing",
                            c: "Implement caching",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "How do you optimize prompt engineering for better API performance?",
                        options: {
                            a: "Use few-shot examples",
                            b: "Implement chain-of-thought prompting",
                            c: "Optimize token usage",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "What's the most effective way to evaluate API response quality?",
                        options: {
                            a: "Human evaluation",
                            b: "Automated metrics",
                            c: "A/B testing",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "How do you implement streaming responses in a web application?",
                        options: {
                            a: "Use Server-Sent Events",
                            b: "Implement WebSocket connections",
                            c: "Use streaming API endpoint",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "What's the best approach for handling context management in conversational AI?",
                        options: {
                            a: "Truncate conversation history",
                            b: "Use conversation summarization",
                            c: "Implement sliding window approach",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "How do you implement cost monitoring and optimization?",
                        options: {
                            a: "Track token usage per request",
                            b: "Implement usage-based caching",
                            c: "Use smaller models when appropriate",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "What's the most effective way to handle API errors and retries?",
                        options: {
                            a: "Implement exponential backoff",
                            b: "Use circuit breaker pattern",
                            c: "Implement graceful degradation",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "üîß OpenAI API",
                        question: "How do you optimize embeddings for semantic search?",
                        options: {
                            a: "Use text-embedding-ada-002",
                            b: "Implement vector quantization",
                            c: "Use hierarchical clustering",
                            d: "All of the above"
                        },
                        correct: "d"
                    },

                    // Hugging Face Interview (41-50)
                    {
                        section: "ü§ó Hugging Face",
                        question: "You're deploying a Hugging Face model to production. What's your deployment strategy?",
                        options: {
                            a: "Use Transformers pipeline",
                            b: "Deploy to Spaces for testing",
                            c: "Use Optimum for optimization",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "How do you optimize model inference speed in production?",
                        options: {
                            a: "Use ONNX runtime",
                            b: "Implement model quantization",
                            c: "Use TorchScript compilation",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "What's the best approach for model versioning in MLOps?",
                        options: {
                            a: "Use model cards for documentation",
                            b: "Implement automated versioning",
                            c: "Use model registry",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "How do you implement distributed training with Accelerate?",
                        options: {
                            a: "Configure deepspeed config",
                            b: "Use accelerator.prepare()",
                            c: "Implement gradient synchronization",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "What's the most effective way to handle model memory issues?",
                        options: {
                            a: "Use gradient checkpointing",
                            b: "Implement model sharding",
                            c: "Use mixed precision training",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "How do you implement model evaluation pipelines?",
                        options: {
                            a: "Use Evaluate library",
                            b: "Implement custom metrics",
                            c: "Use model comparison tools",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "What's the best strategy for dataset versioning?",
                        options: {
                            a: "Use Datasets library features",
                            b: "Implement data versioning",
                            c: "Use data lineage tracking",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "How do you optimize tokenizer performance?",
                        options: {
                            a: "Use fast tokenizers",
                            b: "Implement batch processing",
                            c: "Use parallel tokenization",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "What's the most effective way to handle model serialization?",
                        options: {
                            a: "Use safetensors format",
                            b: "Implement model sharding",
                            c: "Use memory-mapped files",
                            d: "All of the above"
                        },
                        correct: "d"
                    },
                    {
                        section: "ü§ó Hugging Face",
                        question: "How do you implement model monitoring in production?",
                        options: {
                            a: "Track model performance metrics",
                            b: "Implement drift detection",
                            c: "Use model cards for documentation",
                            d: "All of the above"
                        },
                        correct: "d"
                    }
                ];
            }

            initializeElements() {
                this.startScreen = document.getElementById('start-screen');
                this.questionScreen = document.getElementById('question-screen');
                this.resultScreen = document.getElementById('result-screen');

                this.questionSection = document.getElementById('question-section');
                this.questionText = document.getElementById('question-text');
                this.optionLabels = {
                    a: document.getElementById('option-a-text'),
                    b: document.getElementById('option-b-text'),
                    c: document.getElementById('option-c-text'),
                    d: document.getElementById('option-d-text')
                };

                this.currentQuestionSpan = document.getElementById('current-question');
                this.totalQuestionsSpan = document.getElementById('total-questions');
                this.scoreSpan = document.getElementById('score');
                this.progressFill = document.querySelector('.progress-fill');
                this.feedback = document.getElementById('feedback');

                this.totalQuestionsSpan.textContent = this.questions.length;
            }

            bindEvents() {
                document.getElementById('start-btn').addEventListener('click', () => this.startQuiz());
                document.getElementById('next-btn').addEventListener('click', () => this.nextQuestion());
                document.getElementById('prev-btn').addEventListener('click', () => this.previousQuestion());
                document.getElementById('restart-btn').addEventListener('click', () => this.restartQuiz());
                document.getElementById('review-btn').addEventListener('click', () => this.reviewAnswers());

                document.querySelectorAll('.option').forEach(option => {
                    option.addEventListener('click', (e) => this.selectOption(e));
                });
            }

            showStartScreen() {
                this.startScreen.classList.remove('hidden');
                this.questionScreen.classList.add('hidden');
                this.resultScreen.classList.add('hidden');
            }

            startQuiz() {
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.answers.fill(null);
                this.scoredQuestions.clear();
                this.startTime = new Date();

                this.startScreen.classList.add('hidden');
                this.questionScreen.classList.remove('hidden');
                this.resultScreen.classList.add('hidden');

                this.showQuestion();
            }

            showQuestion() {
                const question = this.questions[this.currentQuestionIndex];

                this.questionSection.textContent = question.section;
                this.questionText.textContent = question.question;

                Object.keys(this.optionLabels).forEach(letter => {
                    this.optionLabels[letter].textContent = `${letter.toUpperCase()}) ${question.options[letter]}`;
                });

                document.querySelectorAll('.option').forEach(option => {
                    option.classList.remove('selected', 'correct', 'incorrect');
                });
                document.querySelectorAll('input[name="answer"]').forEach(input => {
                    input.checked = false;
                });

                if (this.answers[this.currentQuestionIndex]) {
                    const selectedOption = document.querySelector(`[data-letter="${this.answers[this.currentQuestionIndex]}"]`);
                    if (selectedOption) {
                        selectedOption.classList.add('selected');
                        document.getElementById(`option-${this.answers[this.currentQuestionIndex]}`).checked = true;

                        const currentQ = this.questions[this.currentQuestionIndex];
                        if (this.answers[this.currentQuestionIndex] === currentQ.correct) {
                            selectedOption.classList.add('correct');
                        } else {
                            selectedOption.classList.add('incorrect');
                            const correctOption = document.querySelector(`[data-letter="${currentQ.correct}"]`);
                            if (correctOption) {
                                correctOption.classList.add('correct');
                            }
                        }
                    }
                }

                this.currentQuestionSpan.textContent = this.currentQuestionIndex + 1;
                this.updateProgress();
                this.updateScore();

                document.getElementById('prev-btn').style.display = this.currentQuestionIndex > 0 ? 'inline-block' : 'none';
                document.getElementById('next-btn').textContent = this.currentQuestionIndex === this.questions.length - 1 ? 'Finish' : 'Next';

                this.feedback.classList.add('hidden');
            }

            selectOption(e) {
                const option = e.currentTarget;
                const letter = option.dataset.letter;
                const question = this.questions[this.currentQuestionIndex];
                const questionIndex = this.currentQuestionIndex;

                document.querySelectorAll('.option').forEach(opt => {
                    opt.classList.remove('selected', 'correct', 'incorrect');
                });
                document.querySelectorAll('input[name="answer"]').forEach(input => {
                    input.checked = false;
                });

                option.classList.add('selected');
                document.getElementById(`option-${letter}`).checked = true;

                if (letter === question.correct) {
                    option.classList.add('correct');

                    if (!this.scoredQuestions.has(questionIndex)) {
                        this.score++;
                        this.scoredQuestions.add(questionIndex);
                        this.updateScore();
                    }

                    this.feedback.textContent = "‚úÖ Correct! Excellent reasoning!";
                    this.feedback.className = "feedback correct";
                    this.feedback.classList.remove('hidden');
                } else {
                    option.classList.add('incorrect');

                    if (this.scoredQuestions.has(questionIndex)) {
                        this.score--;
                        this.scoredQuestions.delete(questionIndex);
                        this.updateScore();
                    }

                    const correctOption = document.querySelector(`[data-letter="${question.correct}"]`);
                    if (correctOption) {
                        correctOption.classList.add('correct');
                    }

                    this.feedback.textContent = `‚ùå Not quite right. The correct approach is ${question.correct.toUpperCase()}) ${question.options[question.correct]}`;
                    this.feedback.className = "feedback incorrect";
                    this.feedback.classList.remove('hidden');
                }

                this.answers[this.currentQuestionIndex] = letter;
            }

            nextQuestion() {
                if (this.currentQuestionIndex < this.questions.length - 1) {
                    this.currentQuestionIndex++;
                    this.showQuestion();
                } else {
                    this.finishQuiz();
                }
            }

            previousQuestion() {
                if (this.currentQuestionIndex > 0) {
                    this.currentQuestionIndex--;
                    this.showQuestion();
                }
            }

            updateProgress() {
                const progress = ((this.currentQuestionIndex + 1) / this.questions.length) * 100;
                this.progressFill.style.width = `${progress}%`;
            }

            updateScore() {
                this.scoreSpan.textContent = this.score;
            }

            finishQuiz() {
                this.endTime = new Date();
                this.calculateFinalScore();

                this.questionScreen.classList.add('hidden');
                this.resultScreen.classList.remove('hidden');

                this.displayResults();
            }

            calculateFinalScore() {
                let calculatedScore = 0;
                this.answers.forEach((answer, index) => {
                    if (answer === this.questions[index].correct) {
                        calculatedScore++;
                    }
                });

                if (calculatedScore !== this.score) {
                    this.score = calculatedScore;
                }
            }

            displayResults() {
                const correct = this.score;
                const incorrect = this.answers.filter((answer, index) =>
                    answer !== null && answer !== this.questions[index].correct
                ).length;
                const skipped = this.answers.filter(answer => answer === null).length;

                document.getElementById('final-score').textContent = `${correct}/${this.questions.length}`;
                document.getElementById('percentage').textContent = `${Math.round((correct / this.questions.length) * 100)}%`;
                document.getElementById('correct-count').textContent = correct;
                document.getElementById('incorrect-count').textContent = incorrect;
                document.getElementById('skipped-count').textContent = skipped;

                this.displayPerformanceBadge(correct);
            }

            displayPerformanceBadge(score) {
                const percentage = (score / this.questions.length) * 100;
                const badgeTitle = document.getElementById('badge-title');
                const badgeDescription = document.getElementById('badge-description');

                if (percentage >= 90) {
                    badgeTitle.textContent = "üèÜ Gen AI Specialist!";
                    badgeDescription.textContent = "Outstanding! You're ready for senior AI roles!";
                    document.getElementById('performance-badge').style.background = "linear-gradient(135deg, #28a745, #20c997)";
                } else if (percentage >= 80) {
                    badgeTitle.textContent = "‚≠ê AI Expert!";
                    badgeDescription.textContent = "Excellent! You demonstrate strong AI expertise!";
                    document.getElementById('performance-badge').style.background = "linear-gradient(135deg, #007bff, #6610f2)";
                } else if (percentage >= 70) {
                    badgeTitle.textContent = "üî• AI Professional!";
                    badgeDescription.textContent = "Good job! You have solid practical AI knowledge!";
                    document.getElementById('performance-badge').style.background = "linear-gradient(135deg, #ffc107, #fd7e14)";
                } else if (percentage >= 60) {
                    badgeTitle.textContent = "‚öôÔ∏è AI Developer!";
                    badgeDescription.textContent = "Not bad! Keep building practical AI experience!";
                    document.getElementById('performance-badge').style.background = "linear-gradient(135deg, #6f42c1, #e83e8c)";
                } else {
                    badgeTitle.textContent = "üå± AI Learner!";
                    badgeDescription.textContent = "Keep learning! AI expertise takes practice!";
                    document.getElementById('performance-badge').style.background = "linear-gradient(135deg, #dc3545, #c82333)";
                }
            }

            restartQuiz() {
                this.currentQuestionIndex = 0;
                this.score = 0;
                this.answers.fill(null);
                this.scoredQuestions.clear();
                this.showStartScreen();
            }

            reviewAnswers() {
                this.currentQuestionIndex = 0;
                this.questionScreen.classList.remove('hidden');
                this.resultScreen.classList.add('hidden');

                document.getElementById('next-btn').textContent = 'Next';
                this.showQuestionWithReview();
            }

            showQuestionWithReview() {
                const question = this.questions[this.currentQuestionIndex];
                const userAnswer = this.answers[this.currentQuestionIndex];

                this.questionSection.textContent = question.section;
                this.questionText.textContent = question.question;

                Object.keys(this.optionLabels).forEach(letter => {
                    this.optionLabels[letter].textContent = `${letter.toUpperCase()}) ${question.options[letter]}`;
                });

                document.querySelectorAll('.option').forEach(option => {
                    const letter = option.dataset.letter;
                    option.classList.remove('selected', 'correct', 'incorrect');

                    if (letter === question.correct) {
                        option.classList.add('correct');
                    }
                    if (letter === userAnswer && userAnswer !== question.correct) {
                        option.classList.add('incorrect');
                    }
                    if (letter === userAnswer && userAnswer === question.correct) {
                        option.classList.add('correct');
                    }
                });

                document.querySelectorAll('input[name="answer"]').forEach(input => {
                    input.disabled = true;
                });

                if (userAnswer === null) {
                    this.feedback.textContent = "‚ùì You skipped this question";
                    this.feedback.className = "feedback";
                } else if (userAnswer === question.correct) {
                    this.feedback.textContent = "‚úÖ Correct!";
                    this.feedback.className = "feedback correct";
                } else {
                    this.feedback.textContent = `‚ùå Incorrect! The correct answer was ${question.correct.toUpperCase()}) ${question.options[question.correct]}`;
                    this.feedback.className = "feedback incorrect";
                }
                this.feedback.classList.remove('hidden');

                document.getElementById('prev-btn').style.display = this.currentQuestionIndex > 0 ? 'inline-block' : 'none';
                document.getElementById('next-btn').textContent = this.currentQuestionIndex === this.questions.length - 1 ? 'Back to Results' : 'Next';

                this.currentQuestionSpan.textContent = this.currentQuestionIndex + 1;
                this.updateProgress();
            }
        }

        document.addEventListener('DOMContentLoaded', () => {
            new GenAIInterviewQuiz();
        });
    </script>
</body>
</html>
